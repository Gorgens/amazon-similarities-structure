---
title: "Agrupamentos"
output: html_notebook
---

```{r}
library(factoextra)
library(cluster)
require(tidyverse)
require(terra)
require(raster)
require(sp)
library(rpart)
require(rpart.plot)
require(randomForest)
```

Importa base de dados ForestPlot

```{r}
full = read.csv2('C:/Users/User/Insync/eric.gorgens@ufvjm.edu.br/Google Drive/pesquisa/paper e orientações/eba transectos lidar/2022 - Robson - Agrupamento estrutura e diversidade/dados_full_10cm.csv')
full[full$site == 'STO','site'] <- 'STO.P'
full[full$site == 'STP','site'] <- 'STO.P'
full[full$site == 'MUF','site'] <- 'MUF.U'
full[full$site == 'MUU','site'] <- 'MUF.U'
full[full$site == 'ETB','site'] <- 'ETA'
full[full$site == 'ETE','site'] <- 'ETA'
full[full$site == 'ETF','site'] <- 'ETA'

```

Espécies mais importantes

```{r}
fullSpecies = full %>% filter(species != 'Indet.') %>%
  filter(epiteto != 'sp.') %>%
  filter(epiteto != 'indet')

species10 = fullSpecies %>% group_by(species) %>%
  summarise(trees = n()/nrow(full) * 100) %>%
  arrange(desc(trees))

species70 = fullSpecies %>% filter(d >= 70) %>%
  group_by(species) %>%
  summarise(trees = n()/nrow(full) * 100) %>%
  arrange(desc(trees))
```

Formula para diversidade de Shannon

```{r}
shannon = function(vector){
  termo1 = -1 * table(vector)/length(vector)
  termo2 = log(table(vector)/length(vector))
  H = sum(termo1 * termo2)
}
```

Analisa variáveis dendrométricas por sitio

```{r}
dados10 = full %>% group_by(site) %>%
  summarise(spH_10 = shannon(species),
            genH_10 = shannon(genero),
            famH_10 = shannon(family),
            dmean_10 = mean(d),
            dmax_10 = max(d),
            dsd_10 = sd(d),
            wdmean_10 = mean(wd),
            wdsd_10 = sd(wd))
```

```{r}
dados70 = full %>% filter(d >= 70) %>%
  group_by(site) %>%
  summarise(spH_70 = shannon(species),
            genH_70 = shannon(genero),
            famH_70 = shannon(family),
            dmean_70 = mean(d),
            dmax_70 = max(d),
            dsd_70 = sd(d),
            wdmean_70 = mean(wd),
            wdsd_70 = sd(wd)) 
```

Analisa as 100 principais especies por sitio

```{r}
esp10 = full %>% filter(species %in% head(species10$species, 100)) %>%
  group_by(site, species) %>%
  summarise(n = n() / length(full$species) * 100) %>%
  spread(species, n)


esp10[is.na(esp10)] <- 0
```

```{r}
esp70 = full %>% filter(species %in% head(species70$species, 100)) %>%
  group_by(site, species) %>%
  summarise(n = n() / length(full$species) * 100) %>%
  spread(species, n)


esp70[is.na(esp70)] <- 0
```

Importa coordenadas sitios

```{r}
sitioCoord = read.csv('dados/siteForestPlots_en.csv')
```

Unir dados

```{r}
df = merge(sitioCoord, dados10, by.x = 'Site', by.y = 'site', all = TRUE)
df = merge(df, dados70, by.x = 'Site', by.y = 'site', all = TRUE)
df = merge(df, esp10, by.x = 'Site', by.y = 'site', all = TRUE, suffixes = c(".x","_10"))
df = merge(df, esp70, by.x = 'Site', by.y = 'site', all = TRUE, suffixes = c("_10","_70"))
```


Importa biogeografia


```{r}
coordinates(df) <- ~Longitude+Latitude
proj4string(df) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
```


```{r}
morrone = shapefile('dados/Morrones.shp', encoding = 'UTF-8')
morrone = spTransform(morrone, crs(df))
```


```{r}
df = cbind(df, over(df, morrone))
head(df)
```


## Discriminante

```{r}
distrib = df@data %>% group_by(Province_1) %>% summarise(sites = n())
distrib
```



```{r}
dfAgrupamento = df@data %>% filter(Province_1 %in% c("Madeira province", "Pará province", "Roraima province", "Xingu-Tapajós province", "Rondônia province"))

dfAgrupamento = dfAgrupamento[, c(6:221, 225)]
dfAgrupamento[is.na(dfAgrupamento)] <- 0
```


```{r}
tree = rpart(Province_1 ~., data = dfAgrupamento)
rpart.plot(tree)
```

```{r}
summary(tree)
```

After training a random forest, it is natural to ask which variables have the most predictive power. Variables with high importance are drivers of the outcome and their values have a significant impact on the outcome values. By contrast, variables with low importance might be omitted from a model, making it simpler and faster to fit and predict. Here are the definitions of the variable importance measures. The first measure is computed from permuting OOB data: For each tree, the prediction error on the out-of-bag portion of the data is recorded (error rate for classification, MSE for regression). Then the same is done after permuting each predictor variable. The difference between the two are then averaged over all trees, and normalized by the standard deviation of the differences. If the standard deviation of the differences is equal to 0 for a variable, the division is not done (but the average is almost always equal to 0 in that case).

```{r}
rfAgrupamento = randomForest(factor(Province_1)~., data = dfAgrupamento, importance=TRUE)
importance(rfAgrupamento)
```


## Agrupamento


```{r}
df = dap10[,2:30]
row.names(df) = dap10$Site.code
df <- na.omit(df)
df <- scale(df)
```

Analisa quantidade de grupos por dois métodos diferentes.

```{r}
fviz_nbclust(df, kmeans, method = "wss", k.max = 30)
```



```{r}
#calculate gap statistic based on number of clusters
gap_stat <- clusGap(df,
                    FUN = kmeans,
                    nstart = 25,
                    K.max = 30,
                    B = 50)

#plot number of clusters vs. gap statistic
fviz_gap_stat(gap_stat)
```

```{r}
km <- kmeans(df, centers = 5, nstart = 25)
fviz_cluster(km, data = df)
```


```{r}
aggregate(USArrests, by=list(cluster=km$cluster), mean)
```


Referencia: [link](https://www.statology.org/k-means-clustering-in-r/).